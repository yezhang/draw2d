方法地址：
https://wdobbie.com/post/gpu-text-rendering-with-vector-textures/

### 触发渲染

在字体渲染时，为了通过调用一次 drawArrays 绘制多个 glyph，需要使用退化三角形，并使用 gl.TRIANGLE_STRIP 模式。
这样可以减少 drawArrays 的调用次数，提高性能。

### 问题1：Atlas 矢量图集如何存储网格数据？

在 demo 中，**Atlas 矢量图集**用于存储字形的矢量数据（贝塞尔曲线）。每个字形被分割成一个网格（grid），每个网格单元（cell）存储与该单元相交的贝塞尔曲线的索引。具体存储方式如下：

1. **网格划分**：

   - 每个字形被划分为一个网格，网格的大小由 `vGridSize` 决定。
   - 每个网格单元存储与该单元相交的贝塞尔曲线的索引。

2. **索引存储**：

   - 每个网格单元存储的贝塞尔曲线索引通过纹理图集（`uAtlasSampler`）来获取。
   - 索引存储在纹理图集的特定位置，通过 `vCurvesMin` 和 `vGridMin` 来定位。
   - 每个网格单元最多可以存储 8 个贝塞尔曲线的索引（前 4 个存储在 `indices1`，后 4 个存储在 `indices2`）。

3. **贝塞尔曲线数据**：

   - 贝塞尔曲线的控制点存储在纹理图集的底部，通过 `fetchVec2` 函数从纹理中读取。
   - 每个贝塞尔曲线由 3 个控制点（起点、控制点、终点）组成，这些控制点通过 `fetchBezier` 函数获取。

4. **网格数据的优化**：
   - 为了节省存储空间，贝塞尔曲线的控制点只存储一次，前一条曲线的终点是下一条曲线的起点。
   - 网格单元中还存储了一个标志（`midClosest`），用于判断当前网格单元的中点是否在字形内部。

### 问题2：顶点着色器给片段着色器提供了什么输入？片段着色器如何根据这些输入判断当前像素的颜色？

#### 顶点着色器的输出（片段着色器的输入）：

顶点着色器通过 `varying` 变量将数据传递给片段着色器。具体传递的变量包括：

- `vCurvesMin`：当前网格单元的贝塞尔曲线索引的起始位置。
- `vGridMin`：当前网格的起始位置。
- `vGridSize`：当前网格的大小。
- `vNormCoord`：当前像素在网格中的归一化坐标。
- `vColor`：当前像素的颜色。

#### 片段着色器如何判断当前像素的颜色：

1. **获取贝塞尔曲线**：

   - 片段着色器通过 `vCurvesMin` 和 `vGridMin` 从纹理图集中获取当前网格单元的贝塞尔曲线索引。
   - 通过 `fetchBezier` 函数获取贝塞尔曲线的控制点。

2. **计算像素覆盖面积**：

   - 片段着色器通过多重采样（`numSS`）来计算当前像素被字形覆盖的面积。
   - 对于每个采样角度，片段着色器计算贝塞尔曲线与像素窗口的交点，并根据交点计算覆盖面积。

3. **判断像素颜色**：
   - 片段着色器根据覆盖面积（`percent`）调整像素的透明度（`gl_FragColor.a`）。
   - 最终像素颜色由 `vColor` 和覆盖面积决定。

### 问题3：片段着色器通过哪个变量表示当前被渲染像素位置，并判断其颜色？

片段着色器通过 `vNormCoord` 表示当前像素在网格中的归一化坐标。`vNormCoord` 是顶点着色器传递过来的变量，表示当前像素在网格中的位置。

#### 具体流程：

1. **像素位置**：

   - `vNormCoord` 表示当前像素在网格中的归一化坐标，范围是 `[0, 1]`。
   - 通过 `vNormCoord` 和 `vGridSize`，片段着色器可以确定当前像素所在的网格单元。

2. **颜色判断**：
   - 片段着色器通过 `vNormCoord` 和 `vGridSize` 获取当前网格单元的贝塞尔曲线索引。
   - 通过计算贝塞尔曲线与像素窗口的交点，片段着色器确定当前像素的覆盖面积。
   - 最终像素颜色由 `vColor` 和覆盖面积（`percent`）决定。

### 总结：

1. **Atlas 矢量图集**通过网格划分和索引存储来高效存储贝塞尔曲线数据。
2. **顶点着色器**通过 `varying` 变量将网格数据、归一化坐标和颜色传递给片段着色器。
3. **片段着色器**通过 `vNormCoord` 表示当前像素位置，并根据贝塞尔曲线的交点计算覆盖面积，最终确定像素颜色。
