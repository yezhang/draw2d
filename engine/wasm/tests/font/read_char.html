<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>读取一个字体文件的glyph数据（永）</title>
    <style>
      #container {
        position: relative;
        width: 540px; /* canvas width + 20px for the ruler */
        height: 540px; /* canvas height + 20px for the ruler */
      }
      #fontCanvas {
        position: absolute;
        top: 40px;
        left: 40px;
        width: 500px;
        height: 500px;
        border: 1px dashed #000;
        box-sizing: border-box;
      }
      #rulerX,
      #rulerY {
        position: absolute;
        background: #f0f0f0;
        font-size: 10px;
        color: #333;
      }
      #rulerX {
        top: 0;
        left: 40px;
        width: 500px;
        height: 40px;
      }
      #rulerY {
        top: 40px;
        left: 0;
        width: 40px;
        height: 500px;
      }
    </style>
  </head>
  <body>
    <div id="container">
      <canvas id="fontCanvas" width="500" height="500"></canvas>
      <canvas id="rulerX" width="500" height="40"></canvas>
      <canvas id="rulerY" width="40" height="500"></canvas>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/opentype.js/1.3.3/opentype.min.js"></script>
    <script>
      async function loadFont(url) {
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        const font = opentype.parse(arrayBuffer);
        return font;
      }
      function drawGrid(ctx, width, height, gridSize) {
        ctx.strokeStyle = "#ddd";
        ctx.lineWidth = 1;

        for (let x = 0; x <= width; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, height);
          ctx.stroke();
        }

        for (let y = 0; y <= height; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(width, y);
          ctx.stroke();
        }
      }

      function drawRulerX(ctx, width, gridSize) {
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1;
        ctx.font = "10px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        for (let x = 0; x <= width; x += gridSize) {
          ctx.beginPath();
          ctx.moveTo(x, 0);
          ctx.lineTo(x, 10);
          ctx.stroke();
          ctx.fillText(x, x, 15);
        }
      }

      function drawRulerY(ctx, height, gridSize) {
        ctx.strokeStyle = "#333";
        ctx.lineWidth = 1;
        ctx.font = "10px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        for (let y = 0; y <= height; y += gridSize) {
          ctx.beginPath();
          ctx.moveTo(0, y);
          ctx.lineTo(10, y);
          ctx.stroke();
          ctx.fillText(y, 15, y);
        }
      }

      function drawPath(ctx, path) {
        ctx.beginPath();
        path.commands.forEach((cmd) => {
          if (cmd.type === "M") {
            ctx.moveTo(cmd.x, cmd.y);
          } else if (cmd.type === "L") {
            ctx.lineTo(cmd.x, cmd.y);
          } else if (cmd.type === "C") {
            ctx.bezierCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
          } else if (cmd.type === "Q") {
            ctx.quadraticCurveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
          } else if (cmd.type === "Z") {
            ctx.closePath();
          }
        });
        ctx.strokeStyle = "#000";
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      function drawPoints(ctx, path) {
        ctx.fillStyle = "red";
        path.commands.forEach((cmd) => {
          if (
            cmd.type === "M" ||
            cmd.type === "L" ||
            cmd.type === "C" ||
            cmd.type === "Q"
          ) {
            ctx.beginPath();
            ctx.arc(cmd.x, cmd.y, 3, 0, 2 * Math.PI);
            ctx.fill();
          }
          if (cmd.type === "C" || cmd.type === "Q") {
            ctx.beginPath();
            ctx.arc(cmd.x1, cmd.y1, 3, 0, 2 * Math.PI);
            ctx.fill();
            if (cmd.type === "C") {
              ctx.beginPath();
              ctx.arc(cmd.x2, cmd.y2, 3, 0, 2 * Math.PI);
              ctx.fill();
            }
          }
        });
      }

      function drawMetrics(ctx, font, glyph, x, y, fontSize) {
        const scale = fontSize / font.unitsPerEm;
        const advanceWidth = glyph.advanceWidth * scale;
        const leftSideBearing = glyph.leftSideBearing * scale;

        // 绘制基线
        ctx.strokeStyle = "blue";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(ctx.canvas.width, y);
        ctx.stroke();

        // 绘制前进宽度
        ctx.strokeStyle = "green";
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + advanceWidth, y);
        ctx.stroke();

        // 绘制左侧边距
        ctx.strokeStyle = "purple";
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + leftSideBearing, y);
        ctx.stroke();

        // 绘制边界框
        ctx.strokeStyle = "orange";
        ctx.strokeRect(
          x + glyph.xMin * scale,
          y - glyph.yMax * scale,
          (glyph.xMax - glyph.xMin) * scale,
          (glyph.yMax - glyph.yMin) * scale,
        );
      }

      async function drawGlyph(fontUrl, char) {
        const font = await loadFont(fontUrl);
        const glyph = font.charToGlyph(char);
        const canvas = document.getElementById("fontCanvas");
        const ctx = canvas.getContext("2d");
        const canvasWidth = canvas.width;
        const canvasHeight = canvas.height;
        const fontSize = Math.min(canvasWidth, canvasHeight) * 0.8; // 使字体大小适应画布

        const scale = fontSize / font.unitsPerEm;

        // 计算边界框的中心位置
        const bboxWidth = (glyph.xMax - glyph.xMin) * scale;
        const bboxHeight = (glyph.yMax - glyph.yMin) * scale;
        const x = (canvasWidth - bboxWidth) / 2 - glyph.xMin * scale;
        const y = (canvasHeight + bboxHeight) / 2 - glyph.yMax * scale;

        console.log("x:", x, "y:", y, "fontSize:", fontSize);

        const path = glyph.getPath(x, y, fontSize); // x, y, fontSize

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        drawGrid(ctx, canvasWidth, canvasHeight, 50); // 绘制网格背景，网格大小为 50

        drawPath(ctx, path); // 绘制路径
        drawPoints(ctx, path); // 绘制锚点和控制点
        glyph.drawMetrics(ctx, x, 10, fontSize);

        // drawMetrics(ctx, font, glyph, x, y, fontSize); // 绘制度量属性
      }

      function drawRulers() {
        const rulerX = document.getElementById("rulerX");
        const rulerY = document.getElementById("rulerY");
        const ctxX = rulerX.getContext("2d");
        const ctxY = rulerY.getContext("2d");
        drawRulerX(ctxX, rulerX.width, 50); // 绘制 X 轴坐标尺，网格大小为 50
        drawRulerY(ctxY, rulerY.height, 50); // 绘制 Y 轴坐标尺，网格大小为 50
      }

      drawRulers();

      drawGlyph("./STSong.ttf", "永");
    </script>
  </body>
</html>
